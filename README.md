# stc-pack

实现类似 Webpack 的文件打包，并支持 stc 的 cluster 并行处理模式，目的在于编译大型项目时候有更优良的性能。

## 和webpack 对比

### 相同点
1. 把各种文件经过处理后变成 js 文件，最后通过一定的规则合并成一个 js 文件。
2. 理论上 webpack 的 loader 也能适配到 stc 的 plugin（transpile）中。

### 不同
1. webpack 从根文件开始递归的处理所有依赖并按照一定的顺序合并代码，由于是单线程执行，最后生成的 bundle 文件是稳定的。
2. stc-pack 依赖 stc 内核，在 transpile 任务中执行相当于webpack loader 的逻辑，然后在 workflow  支持所有的文件并行处理，所有在代码合并的过程不是稳定的，但是更好的利用的多核的性能。

## 当前完成
* 利用 webpack 的 Parser 来处理和获取文件的依赖（使用的 Acorn 和 Babylon 并不兼容所以这块需要和成银讨论，不然性能损耗比较大）
* 如何把代码片段无序的包装合并起来以后，还能让程序正常的执行？这里使用了依赖注入的思想（参考 Angular 的依赖注入），无序的代码片段用函数包装成服务并注册自己（注册的名字 stc-pack 生成）。这时候代码并没有执行，在代码的最后添加一个 bootstrap 来执行入口文件就能让程序正常的执行。
* 实现了把 css 打包的基本逻辑，验证了可行性。
* 实现添加 bootstrap 代码片段，添加在 bundle 文件的最后，如何知道 bundle 已经是最后的？通过对 entry 文件进行依赖递归分析，如果所有依赖完成，那么在代码最后添加 ‘.bootstrap()’片段
* DI 容器部分的公共代码实现，并添加到文件的最前面。
程序已经能编辑并运行一个例子程序了。
* Bundle 这块的逻辑还有不少漏洞，表现在如果模块 m1 和 m2 都依赖模块 m3， 模块 m3 依赖模块 m4，程序会为每一个模块生成一个 bundle（b1, b2, b3, b4)并向上合并，合并完了会删除自己（，当 如果 m4 最后处理发现 m3 已经合并 m1 和 m2 中，系统报找不到 bundle 3. 要解决这个问题，就不能删除合并了的bundle， 而是把这个 bundle 做成一个 delegated-bundle, 把所有往 delegated-bundle 合并的操作代理到它的父级 bundle。
* 优化 bundle 文件合并时的性能，对非入口文件不再生成文件。

## 计划与目标
* 找到一种当所有文件处理完后，分析文件的依赖时候都加载完整，并给出错误提示。
* stc 实现自己的 AST walker， stc-pack 放弃 webpack 的 Parser 获取更好的系统兼容性。
* 实现 webpack-css-loader 的适配。
* 支持代码分块。
* 让分块代码跑起来。
* 建立单元测试。
* 实现 source map。
* 把最后生成代码的文件路径替换成module id，这样能减少文件大小，对性能也有一定的提高。

## 实现逻辑介绍
项目用 AMD 或者 CMD 来声明依赖，而每个依赖的文件又会依赖其它的文件，最后就是一个依赖树，而树的根节点就是入口文件，也就是项目的启动是第一个执行的文件
