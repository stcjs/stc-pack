# stc-pack

实现类似 Webpack 的文件打包，并支持 stc 的 cluster 并行处理模式，目的在于编译大型项目时候有更优良的性能。

## 和webpack 对比

### 相同点
1. 把各种文件经过处理后变成 js 文件，最后通过一定的规则合并成一个 js 文件。
2. 理论上 webpack 的 loader 也能适配到 stc 的 plugin（transpile）中。

### 不同
1. webpack 从根文件开始递归的处理所有依赖并按照一定的顺序合并代码，由于是单线程执行，最后生成的 bundle 文件是稳定的。
2. stc-pack 依赖 stc 内核，主要处理流程在 transpile 任务中，支持所有的文件并行处理，所有在代码合并的过程不是稳定的，但是更好的利用的多核的性能。

## 当前完成
1. 利用 webpack 的 Parser 来处理和获取文件的依赖（使用的 Acorn 和 Babylon 并不兼容所以这块需要和成银讨论，不然性能损耗比较大）
2. 如何把代码片段无序的包装合并起来以后，还能让程序正常的执行？这里使用了依赖注入的思想（参考 Angular 的依赖注入），无序的代码片段用函数包装成服务并注册自己（注册的名字 stc-pack 生成）。这时候代码并没有执行，在代码的最后添加一个 bootstrap 来执行入口文件就能让程序正常的执行。
3. 实现了把 css 打包的基本逻辑，验证了可行性。
4. 实现添加 bootstrap 代码片段，添加在 bundle 文件的最后，如何知道 bundle 已经是最后的？通过对 entry 文件进行依赖递归分析，如果所有依赖完成，那么在代码最后添加 ‘.bootstrap()’片段
5. DI 容器部分的公共代码实现，并添加到文件的最前面。
6. 程序已经能编辑并运行一个例子程序了。

## 计划与目标
1. stc 实现自己的 AST walker， stc-pack 放弃 webpack 的 Parser 获取更好的系统兼容性。
2. 实现 webpack-css-loader 的适配。
3. 支持代码分块。
4. 让分块代码跑起来。
5. 建立单元测试。
6. 优化 bundle 文件合并时的性能，对非入口文件不再生成文件。
7. 实现 source map。

## 实现逻辑介绍
项目用 AMD 或者 CMD 来声明依赖，而每个依赖的文件又会依赖其它的文件，最后就是一个依赖树，而树的根节点就是入口文件，也就是项目的启动是第一个执行的文件
